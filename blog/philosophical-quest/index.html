<!doctype html>

<html lang="en">

<head>
<meta charset="utf-8">
<title>On a philosophical quest &bullet;&#32;
Antonio E. Porreca</title>
<link type="application/atom+xml" rel="alternate" href="https://aeporreca.org/feed.xml" title="Antonio E. Porreca" />
<link rel="stylesheet" type="text/css" href="/assets/css/style.css">
<meta name="viewport" content="width=device-width, initial-scale=0.9">
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>

<body>
<div id="page">
<div id="site-title">
  <a href="/">Antonio E. Porreca</a>
</div>

<div id="menu-bar">
<a href="/">Home</a>
&bullet;
<a href="/papers/">Papers</a>
&bullet;
<a href="/talks/">Talks</a>
&bullet;
<a href="/committees/">Committees</a>
&bullet;
<a href="/blog/">Blog</a>
</div>

<h1 id="title">On a philosophical quest</h1>
<p class="post-date">02 December 2010</p>
<p><em>This was originally posted as an answer to the question <a href="http://cstheory.stackexchange.com/questions/1562/why-go-to-theoretical-computer-science-research/">Why go to theoretical computer science/research?</a> on the <a href="http://cstheory.stackexchange.com">Theoretical Computer Science</a> Stack Exchange website.</em></p>

<p>One of the main reasons why I find the theory of computation (“my” branch of theoretical computer science) fascinating and worth studying is the following one: it provides us with a way to investigate some deep (and sometimes puzzling) philosophical questions.</p>

<p>One of the founders of the theory of computation, Alan Turing, tried to pin down the meaning of “computing a function” for a human being equipped with a piece of paper, by giving a mathematical description of the process. I’m not the only one to think he was extremely successful, and Turing machines proved to be an accurate model of many other computing processes.</p>

<p>Now that we possess a class of mathematical objects describing computations, we can actually prove theorems about them, thus trying to uncover what can be computed, and how it can be computed; it immediately turned out that lots of perfectly legitimate functions cannot be computed at all, and that they can be classified according to a degree of uncomputability (some functions are just “more uncomputable” than others).</p>

<p>Some other guys, the first ones usually identified with Juris Hartmanis and Richard E. Stearns, tried to describe mathematically what it means for a function (resp., a problem) to be <em>hard</em> or <em>easy</em> to compute (resp., to solve). There are several <em>complexity measures</em> according to which the hardness of problems can be described; the most common one is just how much time we need to solve them. Alan Cobham and Jack Edmonds were quite successful in identifying a reasonable notion of “efficient computation”.</p>

<p>Within the computational complexity framework, we can now <em>prove</em> some results that are consistent with our intuitive notion of computation. My favourite example is the time hierarchy theorem: if we are given more time to compute, we can solve harder problems.</p>

<p>The central open problem of complexity theory, <strong>P</strong> vs <strong>NP</strong>, is just a formalisation of another philosophically significant question: is it really harder to solve a problem than to check if an alleged solution of it is indeed correct? I believe this question is worth asking, and answering, independently of its practical significance.</p>

</div>
</body>
</html>

